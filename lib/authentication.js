// Generated by CoffeeScript 1.10.0
(function() {
  var HMAC_SHA1, Authentication, crypto, errors, url, uuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  crypto = require('crypto');
  url = require('url');
  uuid = require('uuid/v4');
  HMAC_SHA1 = require('./hmac-sha1');

  Authentication = (function() {
    function Authentication(service_url_oauth, signature_method) {
        if (!signature_method) {
            this.signer = new HMAC_SHA1();
        }
        this.service_url_oauth = service_url_oauth;
        this.service_url_parts = url.parse(this.service_url_oauth, true);
        this.build_service_headers = bind(this.build_service_headers, this);
        this.build_authorization = bind(this.build_authorization, this);
        this.sign_request = bind(this.sign_request, this);
        this.set_credentials = bind(this.set_credentials, this);
        this.credentials_callback = bind(this.credentials_callback, this);
    }

    Authentication.prototype.set_credentials = function(consumer_key, consumer_secret) {
        this.consumer_key = consumer_key;
        this.consumer_secret = consumer_secret;
    };
    
    Authentication.prototype.credentials_callback = function() {
        return { consumer_key: this.consumer_key, consumer_secret: this.consumer_secret };
    };

    Authentication.prototype.sign_request = function(params, callback) {
      params.oauth_callback = 'about:blank';
      params.oauth_consumer_key = this.consumer_key;
      params.oauth_nonce = uuid.v4();
      params.oauth_signature_method = this.signer.toString();
      params.oauth_timestamp = Math.floor(new Date().getTime()/1000);
      params.oauth_version = "1.0";
      
      // Satisfy the contract required by build_signature
      var req = this.build_request_from_url(this.service_url_oauth);
      params.oauth_signature = this.signer.build_signature(req, params, this.consumer_secret);
      return params;
    };
    
    // Build the request contract required by signer.build_signature
    Authentication.prototype.build_request_from_url = function(service_url_oauth) {
        var tp_url = url.parse(service_url_oauth);
        return {
          url: service_url_oauth,
          protocol: tp_url.protocol.replace(/:/,''),
          headers: {
              host: tp_url.host
          },
          connection: {
              encrypted: (tp_url.protocol === 'https')
          },
          method: "post"
        };
    };
    
    Authentication.prototype.build_service_headers = function(body) {
        return {
          Authorization: this.build_authorization(body),
          'Content-Type': 'application/xml',
          'Content-Length': body.length
      };
    };
    
    Authentication.prototype.build_authorization = function(body) {
      var headers, key, val;
      headers = {
        oauth_version: '1.0',
        oauth_nonce: uuid.v4(),
        oauth_timestamp: Math.round(Date.now() / 1000),
        oauth_consumer_key: this.consumer_key,
        oauth_body_hash: crypto.createHash('sha1').update(body).digest('base64'),
        oauth_signature_method: 'HMAC-SHA1'
      };
      headers.oauth_signature = this.signer.build_signature_raw(this.service_url_oauth, this.service_url_parts, 'POST', headers, this.consumer_secret);
      return {
        Authorization: 'OAuth realm="",' + ((function() {
          var results;
          results = [];
          for (key in headers) {
            val = headers[key];
            results.push(key + "=\"" + (this.special_encode(val)) + "\"");
          }
          return results;
        })()).join(','),
        'Content-Type': 'application/xml',
        'Content-Length': body.length
      };
    };

    Authentication.prototype.validate_authorization = function(auth, body) {
      var headers, key, value;
      var params = auth.split(/,/);
      var headers = {};
      for (var i = 1; i < params.length; i++) {
          var param = params[i];
          var parts = param.split(/=/);
          var key = parts[0];
          headers[key] = decodeURIComponent(parts[1].split(/"/)[1]);
      }
      var signature = headers.oauth_signature;
      delete headers.oauth_signature;
      var signature_method = headers.oauth_signature_method || "HMAC-SHA1";
      this.signer = new HMAC_SHA1(); // TODO Support SHA-256 also
      var consumer_secret = this.credentials_callback(headers.oauth_consumer_key);
      var sig = this.signer.build_signature_raw(this.service_url_oauth, this.service_url_parts, 'POST', headers, consumer_secret);
      var bodyHash = crypto.createHash('sha1').update(body).digest('base64');
      var valid = (sig === signature) && (bodyHash === headers.oauth_body_hash);
      return valid;
    };
    
    Authentication.prototype.special_encode = function(string) {
        return encodeURIComponent(string).replace(/[!'()]/g, escape).replace(/\*/g, '%2A');
    };

    return Authentication;

  })();

  exports = module.exports = Authentication;

}).call(this);
